# Langaku Aggregator

## Overview
Langaku Aggregator exposes a read-only API for summarizing a learner's study activity. The service ingests `LearningRecord` rows produced by upstream collectors, applies timezone-aware bucketing, and returns aggregated word counts and study minutes. The application is implemented as a Django project with a REST interface powered by Django REST Framework.

## Quick Start
```bash
# 1) Clone
git clone https://github.com/RekrapF/langaku-aggregator.git
cd langaku-aggregator

# 2) Prepare environment variables
cp .env.sample .env
# Edit .env if you need to change the password or database name
chmod +x entrypoint.sh

# 3) Start with one command
docker compose up -d --build

# 4) Verify
curl "http://localhost:8000/api/users/test/summary?from=2025-10-01T00:00:00Z&to=2025-10-02T00:00:00Z&granularity=day"
```
On the first run, since there’s no data yet, totals and averages will return placeholder values near zero.

## Endpoints
| Method | Path | Description |
| ------ | ---- | ----------- |
| `GET` | `/api/users/{user_id}/summary` | Returns aggregated word counts and study minutes for the specified user over a requested time window. |

### Query Parameters
- `from` (ISO-8601, required): inclusive window start in UTC.
- `to` (ISO-8601, required): exclusive window end in UTC. Must be after `from`.
- `granularity` (`hour`, `day`, or `month`, required): determines the bucket size for aggregation.
- `timezone` (IANA tz database name, optional, defaults to `UTC`): user-local timezone used for bucketing.

### Response Schema (per bucket)
```json
{
  "bucket_start": "2025-10-01T00:00:00+09:00",
  "wc_sum": 4200,
  "mins_sum": 95
}
```
Buckets with no contributing records still appear with zero-valued aggregates.

## Data Model

### API contract
The `/summary` endpoint returns a JSON array of bucket dictionaries sorted by ascending `bucket_start`. Each element corresponds to a half-open bucket `[bucket_start, bucket_start + granularity)` in the requested timezone.

### Persistence model
`LearningRecord` objects capture the raw study activity:

| Field | Type | Notes |
| ----- | ---- | ----- |
| `id` | UUID | Primary key generated by Django. |
| `user_id` | UUID | Partition key for queries. |
| `idempotency_key` | UUID | Ensures upstream retries do not duplicate records. |
| `word_count` | Integer | Words learned during the session, defaults to `0`. |
| `start_at` | `DateTime` (nullable) | When the session started. |
| `end_at` | `DateTime` (nullable) | When the session ended; used for bucketing. |
| `created_at` / `updated_at` | `DateTime` | Audit timestamps managed by Django. |

Database indexes on `(user_id, end_at)` and `(user_id, start_at)` support efficient range scans.

## Time Semantics & Bucketing
- All incoming query timestamps are coerced into timezone-aware UTC datetimes for validation.
- Bucket boundaries are computed in the user’s local timezone by flooring `end_at` to the nearest bucket start (`hour`, `day`, or `month`).
- Buckets cover the half-open interval `[from, to)` and are emitted even if empty to keep chart axes aligned.
- Daylight-saving transitions are handled by converting through the pytz timezone database; ambiguous instants are resolved using the timezone’s default fold rules.

## Aggregation Logic
1. Validate `granularity` and ensure `from < to` after timezone normalization.
2. Enumerate bucket start instants in the local timezone and pre-allocate zeroed accumulators.
3. Fetch all `LearningRecord` rows whose `end_at` lies inside `[from, to)`.
4. For each record:
   - Skip if `end_at` is missing.
   - Determine the bucket by flooring the local `end_at` to the requested granularity.
   - Add `word_count` (or `0` if null) to the bucket total.
   - If both `start_at` and `end_at` exist on the same local day, add the integer number of whole minutes between them.
5. Emit bucket dictionaries containing ISO-formatted local start times plus the aggregated sums.

## Performance & Concurrency
- Query filtering and ordering leverage database indexes on `(user_id, end_at)`.
- Aggregation occurs in-memory per request to avoid synchronization overhead; for long ranges consider adding pagination or precomputed materialized views.
- The API is stateless, enabling horizontal scaling behind a load balancer. Django’s database connection pooling combined with Postgres row-level locks ensures safe concurrent writes from ingestion processes.

## Validation & Error Handling
- Invalid `granularity` values or malformed timestamps yield `400 Bad Request` responses with descriptive error messages.
- If `from >= to`, the request is rejected to avoid empty or negative windows.
- Missing records result in an empty array rather than an error, ensuring idempotent fetches.
- Server-side exceptions are logged and surfaced as `500 Internal Server Error` responses with a generic message.

## Testing
- Unit tests live under `assignment/tests/` and can be executed with `pytest`.
- Use the provided Docker environment (`docker compose run --rm web pytest`) for reproducible results matching production dependencies.

## Design Trade-offs
- **In-memory aggregation** favors simplicity over pre-aggregation. This keeps writes cheap but can increase response times for large windows.
- **Strict same-day minute counting** avoids assumptions about overnight sessions, at the cost of undercounting cross-midnight activity.
- **Timezone-aware bucketing** prioritizes user experience but introduces pytz dependencies and additional validation complexity.

## Accuracy Improvements (Future Work)
1. **Handle cross-day study sessions** by splitting duration across buckets instead of dropping them entirely.
2. **Estimate missing start times** using heuristics (e.g., typical duration per word) to reduce undercounting when `start_at` is absent.
3. **DST-aware bucket iteration** that consults timezone transition rules to avoid duplicate or skipped buckets around daylight-saving changes.

## OpenAPI Specification
```yaml
openapi: 3.0.3
info:
  title: Langaku Aggregator API
  version: 1.0.0
paths:
  /api/users/{user_id}/summary:
    get:
      summary: Summarize study metrics for a user.
      parameters:
        - in: path
          name: user_id
          schema:
            type: string
            format: uuid
          required: true
        - in: query
          name: from
          schema:
            type: string
            format: date-time
          required: true
        - in: query
          name: to
          schema:
            type: string
            format: date-time
          required: true
        - in: query
          name: granularity
          schema:
            type: string
            enum: [hour, day, month]
          required: true
        - in: query
          name: timezone
          schema:
            type: string
            example: Asia/Tokyo
          required: false
      responses:
        '200':
          description: Aggregated bucket data.
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    bucket_start:
                      type: string
                      format: date-time
                    wc_sum:
                      type: integer
                    mins_sum:
                      type: integer
                  required: [bucket_start, wc_sum, mins_sum]
        '400':
          description: Invalid request parameters.
        '500':
          description: Unexpected server error.
```
